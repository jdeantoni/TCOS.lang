digraph G {
  "0" [label="0:startsModel2_0_7_7" shape="ellipse" ];
  "1" [label="1:terminatesModel2_0_7_7" shape="ellipse" ];
  "2" [label="2:startsarray2_0_2_10_4_0_4_10_7_0_7_7" shape="ellipse" ];
  "3" [label="3:startsVariable2_0_2_10:
void functioninit3Variable(){
sigma[\"Variable2_0_2_10currentValue\"] = new int();
}" shape="ellipse" ];
  "4" [label="4:terminatesVariable2_0_2_10" shape="ellipse" ];
  "5" [label="5:initializeVarStateModificationNode:
void function5initializeVar(){
createVar,int,Variable2_0_2_101430
assignVar,Variable2_0_2_101430,2
//TODO: fix this and avoid memory leak by deleting, constructing appropriately
                const std::lock_guard<std::mutex> lock(sigma_mutex);
                (*((int*)sigma[\"Variable2_0_2_10currentValue\"])) = Variable2_0_2_101430;
}" shape="ellipse" ];
  "6" [label="6:startsVariable4_0_4_10:
void functioninit6Variable(){
sigma[\"Variable4_0_4_10currentValue\"] = new int();
}" shape="ellipse" ];
  "7" [label="7:terminatesVariable4_0_4_10" shape="ellipse" ];
  "8" [label="8:initializeVarStateModificationNode:
void function8initializeVar(){
createVar,int,Variable4_0_4_101430
assignVar,Variable4_0_4_101430,3
//TODO: fix this and avoid memory leak by deleting, constructing appropriately
                const std::lock_guard<std::mutex> lock(sigma_mutex);
                (*((int*)sigma[\"Variable4_0_4_10currentValue\"])) = Variable4_0_4_101430;
}" shape="ellipse" ];
  "9" [label="9:startsAssignment7_0_7_7" shape="ellipse" ];
  "10" [label="10:terminatesAssignment7_0_7_7" shape="ellipse" ];
  "11" [label="11:startsVarRef7_5_7_7:
int function11accessVarRef(){
lock,variableMutex
createVar,int,VarRef7_5_7_71645
accessVar,int,VarRef7_5_7_71645,Variable2_0_2_10currentValuemanager
createVar,int,VarRef7_5_7_7terminates
assignVar,VarRef7_5_7_7terminates,VarRef7_5_7_71645
return,VarRef7_5_7_7terminates
}" shape="ellipse" ];
  "12" [label="12:terminatesVarRef7_5_7_7" shape="ellipse" ];
  "13" [label="13:executeAssignment2StateModificationNode:
void function13executeAssignment2(int resRight){
createVar,int,Assignment7_0_7_72620
assignVar,Assignment7_0_7_72620,resRight
//TODO: fix this and avoid memory leak by deleting, constructing appropriately
                const std::lock_guard<std::mutex> lock(sigma_mutex);                                    
                (*((int*)sigma[\"Variable4_0_4_10currentValue\"])) = Assignment7_0_7_72620;
}" shape="ellipse" ];
  "14" [label="14:terminatesarray2_0_2_10_4_0_4_10_7_0_7_7" shape="ellipse" ];
  "0" -> "2" [label=""];
  "3" -> "5" [label=""];
  "5" -> "4" [label=""];
  "2" -> "3" [label=""];
  "6" -> "8" [label=""];
  "8" -> "7" [label=""];
  "4" -> "6" [label=""];
  "11" -> "12" [label=""];
  "9" -> "11" [label=""];
  "12" -> "13" [label=""];
  "13" -> "10" [label=""];
  "7" -> "9" [label=""];
  "10" -> "14" [label=""];
  "14" -> "1" [label=""];
}