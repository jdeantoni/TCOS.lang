/******************************************************************************
 * This file was generated by langium-cli 2.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const StructuralOperationalSemanticsTerminals = {
    NUMBER: /[0-9]+(\.[0-9]+)?/,
    ID: /\^?[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type AbstractRule = ParserRule | TerminalRule;

export const AbstractRule = 'AbstractRule';

export function isAbstractRule(item: unknown): item is AbstractRule {
    return reflection.isInstance(item, AbstractRule);
}

export type AbstractType = Action | Interface | ParserRule | Type;

export const AbstractType = 'AbstractType';

export function isAbstractType(item: unknown): item is AbstractType {
    return reflection.isInstance(item, AbstractType);
}

export type ClassicalExpression = BinaryExpression | BooleanExpression | MemberCall | NilExpression | NumberExpression | StringExpression | UnaryExpression;

export const ClassicalExpression = 'ClassicalExpression';

export function isClassicalExpression(item: unknown): item is ClassicalExpression {
    return reflection.isInstance(item, ClassicalExpression);
}

export type Condition = Conjunction | Disjunction | LiteralCondition | Negation | ParameterReference;

export const Condition = 'Condition';

export function isCondition(item: unknown): item is Condition {
    return reflection.isInstance(item, Condition);
}

export type Data = Constant | EventValueRef | ValuedEventRefConstantComparison;

export const Data = 'Data';

export function isData(item: unknown): item is Data {
    return reflection.isInstance(item, Data);
}

export type EString = string;

export function isEString(item: unknown): item is EString {
    return (typeof item === 'string' && (/"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/.test(item) || /\^?[_a-zA-Z][\w_]*/.test(item)));
}

export type EventCombination = EventConjunction | EventDisjunction;

export const EventCombination = 'EventCombination';

export function isEventCombination(item: unknown): item is EventCombination {
    return reflection.isInstance(item, EventCombination);
}

export type EventEmission = RuleSync | SimpleEventEmission | ValuedEventEmission;

export const EventEmission = 'EventEmission';

export function isEventEmission(item: unknown): item is EventEmission {
    return reflection.isInstance(item, EventEmission);
}

export type EventExpression = EventCombination | EventRef | NaryEventExpression | ValuedEventRef | ValuedEventRefConstantComparison;

export const EventExpression = 'EventExpression';

export function isEventExpression(item: unknown): item is EventExpression {
    return reflection.isInstance(item, EventExpression);
}

export type EventRef = ExplicitEventRef | SingleRuleSync;

export const EventRef = 'EventRef';

export function isEventRef(item: unknown): item is EventRef {
    return reflection.isInstance(item, EventRef);
}

export type Expression = ClassicalExpression | Constant | EventValueRef | FunctionCallExpr | UnaryMinus | ValuedEventRefConstantComparison;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type FeatureName = 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'interface' | 'returns' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;

export function isFeatureName(item: unknown): item is FeatureName {
    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\^?[_a-zA-Z][\w_]*/.test(item)));
}

export type NamedElement = MethodMember | RWRule | RuleOpening | SoSPrimitiveType | TemporaryVariable | VariableDeclaration;

export const NamedElement = 'NamedElement';

export function isNamedElement(item: unknown): item is NamedElement {
    return reflection.isInstance(item, NamedElement);
}

export type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';

export function isPrimitiveType(item: unknown): item is PrimitiveType {
    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';
}

export type QualifiedName = string;

export function isQualifiedName(item: unknown): item is QualifiedName {
    return typeof item === 'string';
}

export type RuleSync = CollectionRuleSync | SingleRuleSync;

export const RuleSync = 'RuleSync';

export function isRuleSync(item: unknown): item is RuleSync {
    return reflection.isInstance(item, RuleSync);
}

export type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;

export const TypeDefinition = 'TypeDefinition';

export function isTypeDefinition(item: unknown): item is TypeDefinition {
    return reflection.isInstance(item, TypeDefinition);
}

export type ValuedEventRef = ExplicitValuedEventRef | ImplicitValuedEventRef;

export const ValuedEventRef = 'ValuedEventRef';

export function isValuedEventRef(item: unknown): item is ValuedEventRef {
    return reflection.isInstance(item, ValuedEventRef);
}

export type ValuedEventRefConstantComparison = ExplicitValuedEventRefConstantComparison | ImplicitValuedEventRefConstantComparison;

export const ValuedEventRefConstantComparison = 'ValuedEventRefConstantComparison';

export function isValuedEventRefConstantComparison(item: unknown): item is ValuedEventRefConstantComparison {
    return reflection.isInstance(item, ValuedEventRefConstantComparison);
}

export interface AbstractElement extends AstNode {
    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
    cardinality?: '*' | '+' | '?'
    lookahead?: '?!' | '?='
}

export const AbstractElement = 'AbstractElement';

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement);
}

export interface ArrayType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ArrayType';
    elementType: TypeDefinition
}

export const ArrayType = 'ArrayType';

export function isArrayType(item: unknown): item is ArrayType {
    return reflection.isInstance(item, ArrayType);
}

export interface BinaryExpression extends AstNode {
    readonly $container: BinaryExpression | CollectionRuleSync | ExplicitEventRef | ExplicitValuedEventRef | ExplicitValuedEventRefConstantComparison | FunctionCallExpr | ImplicitValuedEventRef | ImplicitValuedEventRefConstantComparison | MemberCall | NaryEventExpression | Premise | SimpleEventEmission | SingleRuleSync | StateModification | UnaryExpression | UnaryMinus | ValuedEventEmission | VariableDeclaration;
    readonly $type: 'BinaryExpression';
    left: ClassicalExpression
    operator: '!=' | '*' | '+' | '-' | '/' | '<' | '<=' | '==' | '>' | '>=' | 'and' | 'or' | 'xor'
    right: ClassicalExpression
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface BooleanExpression extends AstNode {
    readonly $container: BinaryExpression | CollectionRuleSync | ExplicitEventRef | ExplicitValuedEventRef | ExplicitValuedEventRefConstantComparison | FunctionCallExpr | ImplicitValuedEventRef | ImplicitValuedEventRefConstantComparison | MemberCall | NaryEventExpression | Premise | SimpleEventEmission | SingleRuleSync | StateModification | UnaryExpression | UnaryMinus | ValuedEventEmission | VariableDeclaration;
    readonly $type: 'BooleanExpression';
    value?: 'true'
}

export const BooleanExpression = 'BooleanExpression';

export function isBooleanExpression(item: unknown): item is BooleanExpression {
    return reflection.isInstance(item, BooleanExpression);
}

export interface CollectionRuleSync extends AstNode {
    readonly $container: CollectionRuleSync | Conclusion;
    readonly $type: 'CollectionRuleSync';
    collection: ClassicalExpression
    order: 'concurrent' | 'sequential'
    singleRule: EventEmission
    varDecl: NamedElement
}

export const CollectionRuleSync = 'CollectionRuleSync';

export function isCollectionRuleSync(item: unknown): item is CollectionRuleSync {
    return reflection.isInstance(item, CollectionRuleSync);
}

export interface Conclusion extends AstNode {
    readonly $container: RWRule;
    readonly $type: 'Conclusion';
    eventEmissionOperator?: ';' | '||'
    eventemissions: Array<EventEmission>
    statemodifications: Array<StateModification>
}

export const Conclusion = 'Conclusion';

export function isConclusion(item: unknown): item is Conclusion {
    return reflection.isInstance(item, Conclusion);
}

export interface Conjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Conjunction';
    left: Condition
    right: Condition
}

export const Conjunction = 'Conjunction';

export function isConjunction(item: unknown): item is Conjunction {
    return reflection.isInstance(item, Conjunction);
}

export interface Constant extends AstNode {
    readonly $container: FunctionCallExpr | UnaryMinus;
    readonly $type: 'Constant';
    literal: EString
}

export const Constant = 'Constant';

export function isConstant(item: unknown): item is Constant {
    return reflection.isInstance(item, Constant);
}

export interface Disjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Disjunction';
    left: Condition
    right: Condition
}

export const Disjunction = 'Disjunction';

export function isDisjunction(item: unknown): item is Disjunction {
    return reflection.isInstance(item, Disjunction);
}

export interface EventConjunction extends AstNode {
    readonly $container: EventConjunction | EventDisjunction | Premise;
    readonly $type: 'EventConjunction';
    lhs: EventExpression
    rhs: EventExpression
}

export const EventConjunction = 'EventConjunction';

export function isEventConjunction(item: unknown): item is EventConjunction {
    return reflection.isInstance(item, EventConjunction);
}

export interface EventDisjunction extends AstNode {
    readonly $container: EventConjunction | EventDisjunction | Premise;
    readonly $type: 'EventDisjunction';
    lhs: EventExpression
    rhs: EventExpression
}

export const EventDisjunction = 'EventDisjunction';

export function isEventDisjunction(item: unknown): item is EventDisjunction {
    return reflection.isInstance(item, EventDisjunction);
}

export interface EventValueRef extends AstNode {
    readonly $container: FunctionCallExpr | UnaryMinus;
    readonly $type: 'EventValueRef';
    value: Reference<ValuedEventRef>
}

export const EventValueRef = 'EventValueRef';

export function isEventValueRef(item: unknown): item is EventValueRef {
    return reflection.isInstance(item, EventValueRef);
}

export interface ExplicitEventRef extends AstNode {
    readonly $container: EventConjunction | EventDisjunction | Premise;
    readonly $type: 'ExplicitEventRef';
    membercall: ClassicalExpression
}

export const ExplicitEventRef = 'ExplicitEventRef';

export function isExplicitEventRef(item: unknown): item is ExplicitEventRef {
    return reflection.isInstance(item, ExplicitEventRef);
}

export interface ExplicitValuedEventRef extends AstNode {
    readonly $container: EventConjunction | EventDisjunction | Premise;
    readonly $type: 'ExplicitValuedEventRef';
    membercall: ClassicalExpression
    tempVar: NamedElement
}

export const ExplicitValuedEventRef = 'ExplicitValuedEventRef';

export function isExplicitValuedEventRef(item: unknown): item is ExplicitValuedEventRef {
    return reflection.isInstance(item, ExplicitValuedEventRef);
}

export interface ExplicitValuedEventRefConstantComparison extends AstNode {
    readonly $container: EventConjunction | EventDisjunction | FunctionCallExpr | Premise | UnaryMinus;
    readonly $type: 'ExplicitValuedEventRefConstantComparison';
    literal: EString
    membercall: ClassicalExpression
}

export const ExplicitValuedEventRefConstantComparison = 'ExplicitValuedEventRefConstantComparison';

export function isExplicitValuedEventRefConstantComparison(item: unknown): item is ExplicitValuedEventRefConstantComparison {
    return reflection.isInstance(item, ExplicitValuedEventRefConstantComparison);
}

export interface FieldMember extends AstNode {
    readonly $type: 'FieldMember';
    name: string
    type: TypeReference
}

export const FieldMember = 'FieldMember';

export function isFieldMember(item: unknown): item is FieldMember {
    return reflection.isInstance(item, FieldMember);
}

export interface FunctionCallExpr extends AstNode {
    readonly $container: FunctionCallExpr | UnaryMinus;
    readonly $type: 'FunctionCallExpr';
    name: string
    parameters: Array<Expression>
}

export const FunctionCallExpr = 'FunctionCallExpr';

export function isFunctionCallExpr(item: unknown): item is FunctionCallExpr {
    return reflection.isInstance(item, FunctionCallExpr);
}

export interface Grammar extends AstNode {
    readonly $type: 'Grammar';
    definesHiddenTokens: boolean
    hiddenTokens: Array<Reference<AbstractRule>>
    imports: Array<GrammarImport>
    interfaces: Array<Interface>
    isDeclared: boolean
    name?: string
    rules: Array<AbstractRule>
    types: Array<Type>
    usedGrammars: Array<Reference<Grammar>>
}

export const Grammar = 'Grammar';

export function isGrammar(item: unknown): item is Grammar {
    return reflection.isInstance(item, Grammar);
}

export interface GrammarImport extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'GrammarImport';
    path: string
}

export const GrammarImport = 'GrammarImport';

export function isGrammarImport(item: unknown): item is GrammarImport {
    return reflection.isInstance(item, GrammarImport);
}

export interface ImplicitValuedEventRef extends AstNode {
    readonly $container: EventConjunction | EventDisjunction | Premise;
    readonly $type: 'ImplicitValuedEventRef';
    membercall: ClassicalExpression
    tempVar: NamedElement
}

export const ImplicitValuedEventRef = 'ImplicitValuedEventRef';

export function isImplicitValuedEventRef(item: unknown): item is ImplicitValuedEventRef {
    return reflection.isInstance(item, ImplicitValuedEventRef);
}

export interface ImplicitValuedEventRefConstantComparison extends AstNode {
    readonly $container: EventConjunction | EventDisjunction | FunctionCallExpr | Premise | UnaryMinus;
    readonly $type: 'ImplicitValuedEventRefConstantComparison';
    literal: BooleanExpression | NumberExpression | StringExpression
    membercall: ClassicalExpression
}

export const ImplicitValuedEventRefConstantComparison = 'ImplicitValuedEventRefConstantComparison';

export function isImplicitValuedEventRefConstantComparison(item: unknown): item is ImplicitValuedEventRefConstantComparison {
    return reflection.isInstance(item, ImplicitValuedEventRefConstantComparison);
}

export interface ImportStatement extends AstNode {
    readonly $container: SoSSpec;
    readonly $type: 'ImportStatement';
    importURI: string
}

export const ImportStatement = 'ImportStatement';

export function isImportStatement(item: unknown): item is ImportStatement {
    return reflection.isInstance(item, ImportStatement);
}

export interface InferredType extends AstNode {
    readonly $container: Action | ParserRule;
    readonly $type: 'InferredType';
    name: string
}

export const InferredType = 'InferredType';

export function isInferredType(item: unknown): item is InferredType {
    return reflection.isInstance(item, InferredType);
}

export interface Interface extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>
    name: string
    superTypes: Array<Reference<AbstractType>>
}

export const Interface = 'Interface';

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, Interface);
}

export interface LiteralCondition extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'LiteralCondition';
    true: boolean
}

export const LiteralCondition = 'LiteralCondition';

export function isLiteralCondition(item: unknown): item is LiteralCondition {
    return reflection.isInstance(item, LiteralCondition);
}

export interface MemberCall extends AstNode {
    readonly $container: BinaryExpression | CollectionRuleSync | ExplicitEventRef | ExplicitValuedEventRef | ExplicitValuedEventRefConstantComparison | FunctionCallExpr | ImplicitValuedEventRef | ImplicitValuedEventRefConstantComparison | MemberCall | NaryEventExpression | Premise | SimpleEventEmission | SingleRuleSync | StateModification | UnaryExpression | UnaryMinus | ValuedEventEmission | VariableDeclaration;
    readonly $type: 'MemberCall';
    arguments: Array<ClassicalExpression>
    element?: Reference<NamedElement>
    explicitOperationCall: boolean
    previous?: ClassicalExpression
}

export const MemberCall = 'MemberCall';

export function isMemberCall(item: unknown): item is MemberCall {
    return reflection.isInstance(item, MemberCall);
}

export interface MethodMember extends AstNode {
    readonly $container: CollectionRuleSync | ExplicitValuedEventRef | ImplicitValuedEventRef | RuleOpening;
    readonly $type: 'MethodMember';
    name: string
    parameters: Array<Parameter>
    returnType: TypeReference
}

export const MethodMember = 'MethodMember';

export function isMethodMember(item: unknown): item is MethodMember {
    return reflection.isInstance(item, MethodMember);
}

export interface NamedArgument extends AstNode {
    readonly $container: RuleCall;
    readonly $type: 'NamedArgument';
    calledByName: boolean
    parameter?: Reference<Parameter>
    value: Condition
}

export const NamedArgument = 'NamedArgument';

export function isNamedArgument(item: unknown): item is NamedArgument {
    return reflection.isInstance(item, NamedArgument);
}

export interface NaryEventExpression extends AstNode {
    readonly $container: EventConjunction | EventDisjunction | Premise;
    readonly $type: 'NaryEventExpression';
    collection: ClassicalExpression
    policy: SelectionPolicy
}

export const NaryEventExpression = 'NaryEventExpression';

export function isNaryEventExpression(item: unknown): item is NaryEventExpression {
    return reflection.isInstance(item, NaryEventExpression);
}

export interface Negation extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Negation';
    value: Condition
}

export const Negation = 'Negation';

export function isNegation(item: unknown): item is Negation {
    return reflection.isInstance(item, Negation);
}

export interface NilExpression extends AstNode {
    readonly $container: BinaryExpression | CollectionRuleSync | ExplicitEventRef | ExplicitValuedEventRef | ExplicitValuedEventRefConstantComparison | FunctionCallExpr | ImplicitValuedEventRef | ImplicitValuedEventRefConstantComparison | MemberCall | NaryEventExpression | Premise | SimpleEventEmission | SingleRuleSync | StateModification | UnaryExpression | UnaryMinus | ValuedEventEmission | VariableDeclaration;
    readonly $type: 'NilExpression';
    value: 'nil'
}

export const NilExpression = 'NilExpression';

export function isNilExpression(item: unknown): item is NilExpression {
    return reflection.isInstance(item, NilExpression);
}

export interface NumberExpression extends AstNode {
    readonly $container: BinaryExpression | CollectionRuleSync | ExplicitEventRef | ExplicitValuedEventRef | ExplicitValuedEventRefConstantComparison | FunctionCallExpr | ImplicitValuedEventRef | ImplicitValuedEventRefConstantComparison | MemberCall | NaryEventExpression | Premise | SimpleEventEmission | SingleRuleSync | StateModification | UnaryExpression | UnaryMinus | ValuedEventEmission | VariableDeclaration;
    readonly $type: 'NumberExpression';
    value: number
}

export const NumberExpression = 'NumberExpression';

export function isNumberExpression(item: unknown): item is NumberExpression {
    return reflection.isInstance(item, NumberExpression);
}

export interface Parameter extends AstNode {
    readonly $container: MethodMember | ParserRule;
    readonly $type: 'Parameter';
    name: string
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface ParameterReference extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'ParameterReference';
    parameter: Reference<Parameter>
}

export const ParameterReference = 'ParameterReference';

export function isParameterReference(item: unknown): item is ParameterReference {
    return reflection.isInstance(item, ParameterReference);
}

export interface ParserRule extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'ParserRule';
    dataType?: PrimitiveType
    definesHiddenTokens: boolean
    definition: AbstractElement
    entry: boolean
    fragment: boolean
    hiddenTokens: Array<Reference<AbstractRule>>
    inferredType?: InferredType
    name: string
    parameters: Array<Parameter>
    returnType?: Reference<AbstractType>
    wildcard: boolean
}

export const ParserRule = 'ParserRule';

export function isParserRule(item: unknown): item is ParserRule {
    return reflection.isInstance(item, ParserRule);
}

export interface Premise extends AstNode {
    readonly $container: RWRule;
    readonly $type: 'Premise';
    booleanExpression: Array<ClassicalExpression>
    eventExpression: EventExpression
}

export const Premise = 'Premise';

export function isPremise(item: unknown): item is Premise {
    return reflection.isInstance(item, Premise);
}

export interface ReferenceType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ReferenceType';
    referenceType: TypeDefinition
}

export const ReferenceType = 'ReferenceType';

export function isReferenceType(item: unknown): item is ReferenceType {
    return reflection.isInstance(item, ReferenceType);
}

export interface ReturnType extends AstNode {
    readonly $container: TerminalRule;
    readonly $type: 'ReturnType';
    name: PrimitiveType | string
}

export const ReturnType = 'ReturnType';

export function isReturnType(item: unknown): item is ReturnType {
    return reflection.isInstance(item, ReturnType);
}

export interface RuleOpening extends AstNode {
    readonly $container: CollectionRuleSync | ExplicitValuedEventRef | ImplicitValuedEventRef | RuleOpening | SoSSpec;
    readonly $type: 'RuleOpening';
    name?: string
    onRule?: Reference<ParserRule>
    rules: Array<RWRule>
    runtimeState: Array<NamedElement>
}

export const RuleOpening = 'RuleOpening';

export function isRuleOpening(item: unknown): item is RuleOpening {
    return reflection.isInstance(item, RuleOpening);
}

export interface RWRule extends AstNode {
    readonly $container: CollectionRuleSync | ExplicitValuedEventRef | ImplicitValuedEventRef | RuleOpening;
    readonly $type: 'RWRule';
    conclusion: Conclusion
    name: string
    premise: Premise
}

export const RWRule = 'RWRule';

export function isRWRule(item: unknown): item is RWRule {
    return reflection.isInstance(item, RWRule);
}

export interface SelectionPolicy extends AstNode {
    readonly $container: NaryEventExpression;
    readonly $type: 'SelectionPolicy';
    operator?: 'firstOf' | 'lastOf'
}

export const SelectionPolicy = 'SelectionPolicy';

export function isSelectionPolicy(item: unknown): item is SelectionPolicy {
    return reflection.isInstance(item, SelectionPolicy);
}

export interface SimpleEventEmission extends AstNode {
    readonly $container: CollectionRuleSync | Conclusion;
    readonly $type: 'SimpleEventEmission';
    event: ClassicalExpression
}

export const SimpleEventEmission = 'SimpleEventEmission';

export function isSimpleEventEmission(item: unknown): item is SimpleEventEmission {
    return reflection.isInstance(item, SimpleEventEmission);
}

export interface SimpleType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'SimpleType';
    primitiveType?: PrimitiveType
    stringType?: string
    typeRef?: Reference<AbstractType>
}

export const SimpleType = 'SimpleType';

export function isSimpleType(item: unknown): item is SimpleType {
    return reflection.isInstance(item, SimpleType);
}

export interface SingleRuleSync extends AstNode {
    readonly $container: CollectionRuleSync | Conclusion | EventConjunction | EventDisjunction | Premise;
    readonly $type: 'SingleRuleSync';
    member: ClassicalExpression
}

export const SingleRuleSync = 'SingleRuleSync';

export function isSingleRuleSync(item: unknown): item is SingleRuleSync {
    return reflection.isInstance(item, SingleRuleSync);
}

export interface SoSPrimitiveType extends AstNode {
    readonly $container: CollectionRuleSync | ExplicitValuedEventRef | ImplicitValuedEventRef | RuleOpening | TypeReference;
    readonly $type: 'SoSPrimitiveType';
    name: 'Timer' | 'boolean' | 'event' | 'integer' | 'string' | 'void'
}

export const SoSPrimitiveType = 'SoSPrimitiveType';

export function isSoSPrimitiveType(item: unknown): item is SoSPrimitiveType {
    return reflection.isInstance(item, SoSPrimitiveType);
}

export interface SoSSpec extends AstNode {
    readonly $type: 'SoSSpec';
    imports: ImportStatement
    name: string
    rtdAndRules: Array<RuleOpening>
}

export const SoSSpec = 'SoSSpec';

export function isSoSSpec(item: unknown): item is SoSSpec {
    return reflection.isInstance(item, SoSSpec);
}

export interface StateModification extends AstNode {
    readonly $container: Conclusion;
    readonly $type: 'StateModification';
    lhs: ClassicalExpression
    rhs: ClassicalExpression
}

export const StateModification = 'StateModification';

export function isStateModification(item: unknown): item is StateModification {
    return reflection.isInstance(item, StateModification);
}

export interface StringExpression extends AstNode {
    readonly $container: BinaryExpression | CollectionRuleSync | ExplicitEventRef | ExplicitValuedEventRef | ExplicitValuedEventRefConstantComparison | FunctionCallExpr | ImplicitValuedEventRef | ImplicitValuedEventRefConstantComparison | MemberCall | NaryEventExpression | Premise | SimpleEventEmission | SingleRuleSync | StateModification | UnaryExpression | UnaryMinus | ValuedEventEmission | VariableDeclaration;
    readonly $type: 'StringExpression';
    value: string
}

export const StringExpression = 'StringExpression';

export function isStringExpression(item: unknown): item is StringExpression {
    return reflection.isInstance(item, StringExpression);
}

export interface TemporaryVariable extends AstNode {
    readonly $container: CollectionRuleSync | ExplicitValuedEventRef | ImplicitValuedEventRef | RuleOpening;
    readonly $type: 'TemporaryVariable';
    name: string
    type?: TypeReference
}

export const TemporaryVariable = 'TemporaryVariable';

export function isTemporaryVariable(item: unknown): item is TemporaryVariable {
    return reflection.isInstance(item, TemporaryVariable);
}

export interface TerminalRule extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'TerminalRule';
    definition: AbstractElement
    fragment: boolean
    hidden: boolean
    name: string
    type?: ReturnType
}

export const TerminalRule = 'TerminalRule';

export function isTerminalRule(item: unknown): item is TerminalRule {
    return reflection.isInstance(item, TerminalRule);
}

export interface Type extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'Type';
    name: string
    type: TypeDefinition
}

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface TypeAttribute extends AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    isOptional: boolean
    name: FeatureName
    type: TypeDefinition
}

export const TypeAttribute = 'TypeAttribute';

export function isTypeAttribute(item: unknown): item is TypeAttribute {
    return reflection.isInstance(item, TypeAttribute);
}

export interface TypeReference extends AstNode {
    readonly $container: FieldMember | MethodMember | TemporaryVariable | VariableDeclaration;
    readonly $type: 'TypeReference';
    primitive?: SoSPrimitiveType
    reference?: Reference<AbstractRule>
}

export const TypeReference = 'TypeReference';

export function isTypeReference(item: unknown): item is TypeReference {
    return reflection.isInstance(item, TypeReference);
}

export interface UnaryExpression extends AstNode {
    readonly $container: BinaryExpression | CollectionRuleSync | ExplicitEventRef | ExplicitValuedEventRef | ExplicitValuedEventRefConstantComparison | FunctionCallExpr | ImplicitValuedEventRef | ImplicitValuedEventRefConstantComparison | MemberCall | NaryEventExpression | Premise | SimpleEventEmission | SingleRuleSync | StateModification | UnaryExpression | UnaryMinus | ValuedEventEmission | VariableDeclaration;
    readonly $type: 'UnaryExpression';
    operator: '!' | '+' | '-'
    value: ClassicalExpression
}

export const UnaryExpression = 'UnaryExpression';

export function isUnaryExpression(item: unknown): item is UnaryExpression {
    return reflection.isInstance(item, UnaryExpression);
}

export interface UnaryMinus extends AstNode {
    readonly $container: FunctionCallExpr | UnaryMinus;
    readonly $type: 'UnaryMinus';
    expression: Expression
}

export const UnaryMinus = 'UnaryMinus';

export function isUnaryMinus(item: unknown): item is UnaryMinus {
    return reflection.isInstance(item, UnaryMinus);
}

export interface UnionType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'UnionType';
    types: Array<TypeDefinition>
}

export const UnionType = 'UnionType';

export function isUnionType(item: unknown): item is UnionType {
    return reflection.isInstance(item, UnionType);
}

export interface ValuedEventEmission extends AstNode {
    readonly $container: CollectionRuleSync | Conclusion;
    readonly $type: 'ValuedEventEmission';
    data: ClassicalExpression
    event: ClassicalExpression
}

export const ValuedEventEmission = 'ValuedEventEmission';

export function isValuedEventEmission(item: unknown): item is ValuedEventEmission {
    return reflection.isInstance(item, ValuedEventEmission);
}

export interface VariableDeclaration extends AstNode {
    readonly $container: CollectionRuleSync | ExplicitValuedEventRef | ImplicitValuedEventRef | RuleOpening;
    readonly $type: 'VariableDeclaration';
    assignment: boolean
    name: string
    type?: TypeReference
    value?: ClassicalExpression
}

export const VariableDeclaration = 'VariableDeclaration';

export function isVariableDeclaration(item: unknown): item is VariableDeclaration {
    return reflection.isInstance(item, VariableDeclaration);
}

export interface Action extends AbstractElement {
    readonly $type: 'Action';
    feature?: FeatureName
    inferredType?: InferredType
    operator?: '+=' | '='
    type?: Reference<AbstractType>
}

export const Action = 'Action';

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action);
}

export interface Alternatives extends AbstractElement {
    readonly $type: 'Alternatives';
    elements: Array<AbstractElement>
}

export const Alternatives = 'Alternatives';

export function isAlternatives(item: unknown): item is Alternatives {
    return reflection.isInstance(item, Alternatives);
}

export interface Assignment extends AbstractElement {
    readonly $type: 'Assignment';
    feature: FeatureName
    operator: '+=' | '=' | '?='
    terminal: AbstractElement
}

export const Assignment = 'Assignment';

export function isAssignment(item: unknown): item is Assignment {
    return reflection.isInstance(item, Assignment);
}

export interface CharacterRange extends AbstractElement {
    readonly $type: 'CharacterRange';
    left: Keyword
    right?: Keyword
}

export const CharacterRange = 'CharacterRange';

export function isCharacterRange(item: unknown): item is CharacterRange {
    return reflection.isInstance(item, CharacterRange);
}

export interface CrossReference extends AbstractElement {
    readonly $type: 'CrossReference';
    deprecatedSyntax: boolean
    terminal?: AbstractElement
    type: Reference<AbstractType>
}

export const CrossReference = 'CrossReference';

export function isCrossReference(item: unknown): item is CrossReference {
    return reflection.isInstance(item, CrossReference);
}

export interface EndOfFile extends AbstractElement {
    readonly $type: 'EndOfFile';
}

export const EndOfFile = 'EndOfFile';

export function isEndOfFile(item: unknown): item is EndOfFile {
    return reflection.isInstance(item, EndOfFile);
}

export interface Group extends AbstractElement {
    readonly $type: 'Group';
    elements: Array<AbstractElement>
    guardCondition?: Condition
}

export const Group = 'Group';

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group);
}

export interface Keyword extends AbstractElement {
    readonly $container: CharacterRange;
    readonly $type: 'Keyword';
    value: string
}

export const Keyword = 'Keyword';

export function isKeyword(item: unknown): item is Keyword {
    return reflection.isInstance(item, Keyword);
}

export interface NegatedToken extends AbstractElement {
    readonly $type: 'NegatedToken';
    terminal: AbstractElement
}

export const NegatedToken = 'NegatedToken';

export function isNegatedToken(item: unknown): item is NegatedToken {
    return reflection.isInstance(item, NegatedToken);
}

export interface RegexToken extends AbstractElement {
    readonly $type: 'RegexToken';
    regex: string
}

export const RegexToken = 'RegexToken';

export function isRegexToken(item: unknown): item is RegexToken {
    return reflection.isInstance(item, RegexToken);
}

export interface RuleCall extends AbstractElement {
    readonly $type: 'RuleCall';
    arguments: Array<NamedArgument>
    rule: Reference<AbstractRule>
}

export const RuleCall = 'RuleCall';

export function isRuleCall(item: unknown): item is RuleCall {
    return reflection.isInstance(item, RuleCall);
}

export interface TerminalAlternatives extends AbstractElement {
    readonly $type: 'TerminalAlternatives';
    elements: Array<AbstractElement>
}

export const TerminalAlternatives = 'TerminalAlternatives';

export function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {
    return reflection.isInstance(item, TerminalAlternatives);
}

export interface TerminalGroup extends AbstractElement {
    readonly $type: 'TerminalGroup';
    elements: Array<AbstractElement>
}

export const TerminalGroup = 'TerminalGroup';

export function isTerminalGroup(item: unknown): item is TerminalGroup {
    return reflection.isInstance(item, TerminalGroup);
}

export interface TerminalRuleCall extends AbstractElement {
    readonly $type: 'TerminalRuleCall';
    rule: Reference<TerminalRule>
}

export const TerminalRuleCall = 'TerminalRuleCall';

export function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {
    return reflection.isInstance(item, TerminalRuleCall);
}

export interface UnorderedGroup extends AbstractElement {
    readonly $type: 'UnorderedGroup';
    elements: Array<AbstractElement>
}

export const UnorderedGroup = 'UnorderedGroup';

export function isUnorderedGroup(item: unknown): item is UnorderedGroup {
    return reflection.isInstance(item, UnorderedGroup);
}

export interface UntilToken extends AbstractElement {
    readonly $type: 'UntilToken';
    terminal: AbstractElement
}

export const UntilToken = 'UntilToken';

export function isUntilToken(item: unknown): item is UntilToken {
    return reflection.isInstance(item, UntilToken);
}

export interface Wildcard extends AbstractElement {
    readonly $type: 'Wildcard';
}

export const Wildcard = 'Wildcard';

export function isWildcard(item: unknown): item is Wildcard {
    return reflection.isInstance(item, Wildcard);
}

export type StructuralOperationalSemanticsAstType = {
    AbstractElement: AbstractElement
    AbstractRule: AbstractRule
    AbstractType: AbstractType
    Action: Action
    Alternatives: Alternatives
    ArrayType: ArrayType
    Assignment: Assignment
    BinaryExpression: BinaryExpression
    BooleanExpression: BooleanExpression
    CharacterRange: CharacterRange
    ClassicalExpression: ClassicalExpression
    CollectionRuleSync: CollectionRuleSync
    Conclusion: Conclusion
    Condition: Condition
    Conjunction: Conjunction
    Constant: Constant
    CrossReference: CrossReference
    Data: Data
    Disjunction: Disjunction
    EndOfFile: EndOfFile
    EventCombination: EventCombination
    EventConjunction: EventConjunction
    EventDisjunction: EventDisjunction
    EventEmission: EventEmission
    EventExpression: EventExpression
    EventRef: EventRef
    EventValueRef: EventValueRef
    ExplicitEventRef: ExplicitEventRef
    ExplicitValuedEventRef: ExplicitValuedEventRef
    ExplicitValuedEventRefConstantComparison: ExplicitValuedEventRefConstantComparison
    Expression: Expression
    FieldMember: FieldMember
    FunctionCallExpr: FunctionCallExpr
    Grammar: Grammar
    GrammarImport: GrammarImport
    Group: Group
    ImplicitValuedEventRef: ImplicitValuedEventRef
    ImplicitValuedEventRefConstantComparison: ImplicitValuedEventRefConstantComparison
    ImportStatement: ImportStatement
    InferredType: InferredType
    Interface: Interface
    Keyword: Keyword
    LiteralCondition: LiteralCondition
    MemberCall: MemberCall
    MethodMember: MethodMember
    NamedArgument: NamedArgument
    NamedElement: NamedElement
    NaryEventExpression: NaryEventExpression
    NegatedToken: NegatedToken
    Negation: Negation
    NilExpression: NilExpression
    NumberExpression: NumberExpression
    Parameter: Parameter
    ParameterReference: ParameterReference
    ParserRule: ParserRule
    Premise: Premise
    RWRule: RWRule
    ReferenceType: ReferenceType
    RegexToken: RegexToken
    ReturnType: ReturnType
    RuleCall: RuleCall
    RuleOpening: RuleOpening
    RuleSync: RuleSync
    SelectionPolicy: SelectionPolicy
    SimpleEventEmission: SimpleEventEmission
    SimpleType: SimpleType
    SingleRuleSync: SingleRuleSync
    SoSPrimitiveType: SoSPrimitiveType
    SoSSpec: SoSSpec
    StateModification: StateModification
    StringExpression: StringExpression
    TemporaryVariable: TemporaryVariable
    TerminalAlternatives: TerminalAlternatives
    TerminalGroup: TerminalGroup
    TerminalRule: TerminalRule
    TerminalRuleCall: TerminalRuleCall
    Type: Type
    TypeAttribute: TypeAttribute
    TypeDefinition: TypeDefinition
    TypeReference: TypeReference
    UnaryExpression: UnaryExpression
    UnaryMinus: UnaryMinus
    UnionType: UnionType
    UnorderedGroup: UnorderedGroup
    UntilToken: UntilToken
    ValuedEventEmission: ValuedEventEmission
    ValuedEventRef: ValuedEventRef
    ValuedEventRefConstantComparison: ValuedEventRefConstantComparison
    VariableDeclaration: VariableDeclaration
    Wildcard: Wildcard
}

export class StructuralOperationalSemanticsAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AbstractElement', 'AbstractRule', 'AbstractType', 'Action', 'Alternatives', 'ArrayType', 'Assignment', 'BinaryExpression', 'BooleanExpression', 'CharacterRange', 'ClassicalExpression', 'CollectionRuleSync', 'Conclusion', 'Condition', 'Conjunction', 'Constant', 'CrossReference', 'Data', 'Disjunction', 'EndOfFile', 'EventCombination', 'EventConjunction', 'EventDisjunction', 'EventEmission', 'EventExpression', 'EventRef', 'EventValueRef', 'ExplicitEventRef', 'ExplicitValuedEventRef', 'ExplicitValuedEventRefConstantComparison', 'Expression', 'FieldMember', 'FunctionCallExpr', 'Grammar', 'GrammarImport', 'Group', 'ImplicitValuedEventRef', 'ImplicitValuedEventRefConstantComparison', 'ImportStatement', 'InferredType', 'Interface', 'Keyword', 'LiteralCondition', 'MemberCall', 'MethodMember', 'NamedArgument', 'NamedElement', 'NaryEventExpression', 'NegatedToken', 'Negation', 'NilExpression', 'NumberExpression', 'Parameter', 'ParameterReference', 'ParserRule', 'Premise', 'RWRule', 'ReferenceType', 'RegexToken', 'ReturnType', 'RuleCall', 'RuleOpening', 'RuleSync', 'SelectionPolicy', 'SimpleEventEmission', 'SimpleType', 'SingleRuleSync', 'SoSPrimitiveType', 'SoSSpec', 'StateModification', 'StringExpression', 'TemporaryVariable', 'TerminalAlternatives', 'TerminalGroup', 'TerminalRule', 'TerminalRuleCall', 'Type', 'TypeAttribute', 'TypeDefinition', 'TypeReference', 'UnaryExpression', 'UnaryMinus', 'UnionType', 'UnorderedGroup', 'UntilToken', 'ValuedEventEmission', 'ValuedEventRef', 'ValuedEventRefConstantComparison', 'VariableDeclaration', 'Wildcard'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Action: {
                return this.isSubtype(AbstractElement, supertype) || this.isSubtype(AbstractType, supertype);
            }
            case Alternatives:
            case Assignment:
            case CharacterRange:
            case CrossReference:
            case EndOfFile:
            case Group:
            case Keyword:
            case NegatedToken:
            case RegexToken:
            case RuleCall:
            case TerminalAlternatives:
            case TerminalGroup:
            case TerminalRuleCall:
            case UnorderedGroup:
            case UntilToken:
            case Wildcard: {
                return this.isSubtype(AbstractElement, supertype);
            }
            case ArrayType:
            case ReferenceType:
            case SimpleType:
            case UnionType: {
                return this.isSubtype(TypeDefinition, supertype);
            }
            case BinaryExpression:
            case BooleanExpression:
            case MemberCall:
            case NilExpression:
            case NumberExpression:
            case StringExpression:
            case UnaryExpression: {
                return this.isSubtype(ClassicalExpression, supertype);
            }
            case ClassicalExpression:
            case FunctionCallExpr:
            case UnaryMinus: {
                return this.isSubtype(Expression, supertype);
            }
            case CollectionRuleSync: {
                return this.isSubtype(RuleSync, supertype);
            }
            case Conjunction:
            case Disjunction:
            case LiteralCondition:
            case Negation:
            case ParameterReference: {
                return this.isSubtype(Condition, supertype);
            }
            case Constant:
            case EventValueRef: {
                return this.isSubtype(Data, supertype) || this.isSubtype(Expression, supertype);
            }
            case EventCombination:
            case EventRef:
            case NaryEventExpression:
            case ValuedEventRef: {
                return this.isSubtype(EventExpression, supertype);
            }
            case EventConjunction:
            case EventDisjunction: {
                return this.isSubtype(EventCombination, supertype);
            }
            case ExplicitEventRef: {
                return this.isSubtype(EventRef, supertype);
            }
            case ExplicitValuedEventRef:
            case ImplicitValuedEventRef: {
                return this.isSubtype(ValuedEventRef, supertype);
            }
            case ExplicitValuedEventRefConstantComparison:
            case ImplicitValuedEventRefConstantComparison: {
                return this.isSubtype(ValuedEventRefConstantComparison, supertype);
            }
            case Interface:
            case Type: {
                return this.isSubtype(AbstractType, supertype);
            }
            case MethodMember:
            case RuleOpening:
            case RWRule:
            case SoSPrimitiveType:
            case TemporaryVariable:
            case VariableDeclaration: {
                return this.isSubtype(NamedElement, supertype);
            }
            case ParserRule: {
                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);
            }
            case RuleSync:
            case SimpleEventEmission:
            case ValuedEventEmission: {
                return this.isSubtype(EventEmission, supertype);
            }
            case SingleRuleSync: {
                return this.isSubtype(EventRef, supertype) || this.isSubtype(RuleSync, supertype);
            }
            case TerminalRule: {
                return this.isSubtype(AbstractRule, supertype);
            }
            case ValuedEventRefConstantComparison: {
                return this.isSubtype(Data, supertype) || this.isSubtype(EventExpression, supertype) || this.isSubtype(Expression, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Action:type':
            case 'CrossReference:type':
            case 'Interface:superTypes':
            case 'ParserRule:returnType':
            case 'SimpleType:typeRef': {
                return AbstractType;
            }
            case 'EventValueRef:value': {
                return ValuedEventRef;
            }
            case 'Grammar:hiddenTokens':
            case 'ParserRule:hiddenTokens':
            case 'RuleCall:rule':
            case 'TypeReference:reference': {
                return AbstractRule;
            }
            case 'Grammar:usedGrammars': {
                return Grammar;
            }
            case 'MemberCall:element': {
                return NamedElement;
            }
            case 'NamedArgument:parameter':
            case 'ParameterReference:parameter': {
                return Parameter;
            }
            case 'RuleOpening:onRule': {
                return ParserRule;
            }
            case 'TerminalRuleCall:rule': {
                return TerminalRule;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Conclusion': {
                return {
                    name: 'Conclusion',
                    mandatory: [
                        { name: 'eventemissions', type: 'array' },
                        { name: 'statemodifications', type: 'array' }
                    ]
                };
            }
            case 'FunctionCallExpr': {
                return {
                    name: 'FunctionCallExpr',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'Grammar': {
                return {
                    name: 'Grammar',
                    mandatory: [
                        { name: 'definesHiddenTokens', type: 'boolean' },
                        { name: 'hiddenTokens', type: 'array' },
                        { name: 'imports', type: 'array' },
                        { name: 'interfaces', type: 'array' },
                        { name: 'isDeclared', type: 'boolean' },
                        { name: 'rules', type: 'array' },
                        { name: 'types', type: 'array' },
                        { name: 'usedGrammars', type: 'array' }
                    ]
                };
            }
            case 'Interface': {
                return {
                    name: 'Interface',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'superTypes', type: 'array' }
                    ]
                };
            }
            case 'LiteralCondition': {
                return {
                    name: 'LiteralCondition',
                    mandatory: [
                        { name: 'true', type: 'boolean' }
                    ]
                };
            }
            case 'MemberCall': {
                return {
                    name: 'MemberCall',
                    mandatory: [
                        { name: 'arguments', type: 'array' },
                        { name: 'explicitOperationCall', type: 'boolean' }
                    ]
                };
            }
            case 'MethodMember': {
                return {
                    name: 'MethodMember',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'NamedArgument': {
                return {
                    name: 'NamedArgument',
                    mandatory: [
                        { name: 'calledByName', type: 'boolean' }
                    ]
                };
            }
            case 'ParserRule': {
                return {
                    name: 'ParserRule',
                    mandatory: [
                        { name: 'definesHiddenTokens', type: 'boolean' },
                        { name: 'entry', type: 'boolean' },
                        { name: 'fragment', type: 'boolean' },
                        { name: 'hiddenTokens', type: 'array' },
                        { name: 'parameters', type: 'array' },
                        { name: 'wildcard', type: 'boolean' }
                    ]
                };
            }
            case 'Premise': {
                return {
                    name: 'Premise',
                    mandatory: [
                        { name: 'booleanExpression', type: 'array' }
                    ]
                };
            }
            case 'RuleOpening': {
                return {
                    name: 'RuleOpening',
                    mandatory: [
                        { name: 'rules', type: 'array' },
                        { name: 'runtimeState', type: 'array' }
                    ]
                };
            }
            case 'SoSSpec': {
                return {
                    name: 'SoSSpec',
                    mandatory: [
                        { name: 'rtdAndRules', type: 'array' }
                    ]
                };
            }
            case 'TerminalRule': {
                return {
                    name: 'TerminalRule',
                    mandatory: [
                        { name: 'fragment', type: 'boolean' },
                        { name: 'hidden', type: 'boolean' }
                    ]
                };
            }
            case 'TypeAttribute': {
                return {
                    name: 'TypeAttribute',
                    mandatory: [
                        { name: 'isOptional', type: 'boolean' }
                    ]
                };
            }
            case 'UnionType': {
                return {
                    name: 'UnionType',
                    mandatory: [
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            case 'VariableDeclaration': {
                return {
                    name: 'VariableDeclaration',
                    mandatory: [
                        { name: 'assignment', type: 'boolean' }
                    ]
                };
            }
            case 'Alternatives': {
                return {
                    name: 'Alternatives',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'CrossReference': {
                return {
                    name: 'CrossReference',
                    mandatory: [
                        { name: 'deprecatedSyntax', type: 'boolean' }
                    ]
                };
            }
            case 'Group': {
                return {
                    name: 'Group',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'RuleCall': {
                return {
                    name: 'RuleCall',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'TerminalAlternatives': {
                return {
                    name: 'TerminalAlternatives',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'TerminalGroup': {
                return {
                    name: 'TerminalGroup',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'UnorderedGroup': {
                return {
                    name: 'UnorderedGroup',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new StructuralOperationalSemanticsAstReflection();
