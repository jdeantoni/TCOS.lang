/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type BooleanExpression = BooleanConst | Conjunction | Disjunction;

export const BooleanExpression = 'BooleanExpression';

export function isBooleanExpression(item: unknown): item is BooleanExpression {
    return reflection.isInstance(item, BooleanExpression);
}

export type Expr = BooleanExpression | Plus | VarRef;

export const Expr = 'Expr';

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr);
}

export type Statement = Assignment | Bloc | Expr | FunctionCall | If | ParallelBloc | PeriodicBloc | Variable | While;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export interface Assignment extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'Assignment';
    expr: Expr
    variable: Reference<Variable>
}

export const Assignment = 'Assignment';

export function isAssignment(item: unknown): item is Assignment {
    return reflection.isInstance(item, Assignment);
}

export interface Bloc extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'Bloc';
    statements: Array<Statement>
}

export const Bloc = 'Bloc';

export function isBloc(item: unknown): item is Bloc {
    return reflection.isInstance(item, Bloc);
}

export interface BooleanConst extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'BooleanConst';
    value: 'false' | 'true'
}

export const BooleanConst = 'BooleanConst';

export function isBooleanConst(item: unknown): item is BooleanConst {
    return reflection.isInstance(item, BooleanConst);
}

export interface Conjunction extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'Conjunction';
    lhs: BooleanExpression
    rhs: BooleanExpression
}

export const Conjunction = 'Conjunction';

export function isConjunction(item: unknown): item is Conjunction {
    return reflection.isInstance(item, Conjunction);
}

export interface Disjunction extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'Disjunction';
    lhs: BooleanExpression
    rhs: BooleanExpression
}

export const Disjunction = 'Disjunction';

export function isDisjunction(item: unknown): item is Disjunction {
    return reflection.isInstance(item, Disjunction);
}

export interface FunctionCall extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'FunctionCall';
    args: Array<Expr>
    theFunction: Reference<FunctionDef>
}

export const FunctionCall = 'FunctionCall';

export function isFunctionCall(item: unknown): item is FunctionCall {
    return reflection.isInstance(item, FunctionCall);
}

export interface FunctionDef extends AstNode {
    readonly $container: Model;
    readonly $type: 'FunctionDef';
    body: Bloc
    name: string
    params: Array<string>
}

export const FunctionDef = 'FunctionDef';

export function isFunctionDef(item: unknown): item is FunctionDef {
    return reflection.isInstance(item, FunctionDef);
}

export interface If extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'If';
    cond: VarRef
    else: Bloc
    then: Bloc
}

export const If = 'If';

export function isIf(item: unknown): item is If {
    return reflection.isInstance(item, If);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    functionDefs: Array<FunctionDef>
    statements: Array<Statement>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface ParallelBloc extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'ParallelBloc';
    statements: Array<Statement>
}

export const ParallelBloc = 'ParallelBloc';

export function isParallelBloc(item: unknown): item is ParallelBloc {
    return reflection.isInstance(item, ParallelBloc);
}

export interface PeriodicBloc extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'PeriodicBloc';
    bloc: Bloc
    time: number
}

export const PeriodicBloc = 'PeriodicBloc';

export function isPeriodicBloc(item: unknown): item is PeriodicBloc {
    return reflection.isInstance(item, PeriodicBloc);
}

export interface Plus extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'Plus';
    left: Expr
    right: Expr
}

export const Plus = 'Plus';

export function isPlus(item: unknown): item is Plus {
    return reflection.isInstance(item, Plus);
}

export interface Variable extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'Variable';
    initialValue?: number
    name: string
}

export const Variable = 'Variable';

export function isVariable(item: unknown): item is Variable {
    return reflection.isInstance(item, Variable);
}

export interface VarRef extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'VarRef';
    theVar: Reference<Variable>
}

export const VarRef = 'VarRef';

export function isVarRef(item: unknown): item is VarRef {
    return reflection.isInstance(item, VarRef);
}

export interface While extends AstNode {
    readonly $container: Assignment | Bloc | Conjunction | Disjunction | FunctionCall | FunctionDef | If | Model | ParallelBloc | PeriodicBloc | Plus | While;
    readonly $type: 'While';
    body: Bloc
    cond: VarRef
}

export const While = 'While';

export function isWhile(item: unknown): item is While {
    return reflection.isInstance(item, While);
}

export interface SimpleLAstType {
    Assignment: Assignment
    Bloc: Bloc
    BooleanConst: BooleanConst
    BooleanExpression: BooleanExpression
    Conjunction: Conjunction
    Disjunction: Disjunction
    Expr: Expr
    FunctionCall: FunctionCall
    FunctionDef: FunctionDef
    If: If
    Model: Model
    ParallelBloc: ParallelBloc
    PeriodicBloc: PeriodicBloc
    Plus: Plus
    Statement: Statement
    VarRef: VarRef
    Variable: Variable
    While: While
}

export class SimpleLAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Assignment', 'Bloc', 'BooleanConst', 'BooleanExpression', 'Conjunction', 'Disjunction', 'Expr', 'FunctionCall', 'FunctionDef', 'If', 'Model', 'ParallelBloc', 'PeriodicBloc', 'Plus', 'Statement', 'VarRef', 'Variable', 'While'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Assignment:
            case Bloc:
            case FunctionCall:
            case If:
            case ParallelBloc:
            case PeriodicBloc:
            case Variable:
            case While:
            case Expr: {
                return this.isSubtype(Statement, supertype);
            }
            case BooleanConst:
            case Conjunction:
            case Disjunction: {
                return this.isSubtype(BooleanExpression, supertype);
            }
            case Plus:
            case VarRef:
            case BooleanExpression: {
                return this.isSubtype(Expr, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Assignment:variable':
            case 'VarRef:theVar': {
                return Variable;
            }
            case 'FunctionCall:theFunction': {
                return FunctionDef;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Bloc': {
                return {
                    name: 'Bloc',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'FunctionCall': {
                return {
                    name: 'FunctionCall',
                    mandatory: [
                        { name: 'args', type: 'array' }
                    ]
                };
            }
            case 'FunctionDef': {
                return {
                    name: 'FunctionDef',
                    mandatory: [
                        { name: 'params', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'functionDefs', type: 'array' },
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'ParallelBloc': {
                return {
                    name: 'ParallelBloc',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new SimpleLAstReflection();
