"use strict";
/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.reflection = exports.SimpleLAstReflection = exports.isWhile = exports.While = exports.isVarRef = exports.VarRef = exports.isVariable = exports.Variable = exports.isPlus = exports.Plus = exports.isPeriodicBloc = exports.PeriodicBloc = exports.isParallelBloc = exports.ParallelBloc = exports.isModel = exports.Model = exports.isIf = exports.If = exports.isFunctionDef = exports.FunctionDef = exports.isFunctionCall = exports.FunctionCall = exports.isDisjunction = exports.Disjunction = exports.isConjunction = exports.Conjunction = exports.isBooleanConst = exports.BooleanConst = exports.isBloc = exports.Bloc = exports.isAssignment = exports.Assignment = exports.isStatement = exports.Statement = exports.isExpr = exports.Expr = exports.isBooleanExpression = exports.BooleanExpression = void 0;
/* eslint-disable */
var langium_1 = require("langium");
exports.BooleanExpression = 'BooleanExpression';
function isBooleanExpression(item) {
    return exports.reflection.isInstance(item, exports.BooleanExpression);
}
exports.isBooleanExpression = isBooleanExpression;
exports.Expr = 'Expr';
function isExpr(item) {
    return exports.reflection.isInstance(item, exports.Expr);
}
exports.isExpr = isExpr;
exports.Statement = 'Statement';
function isStatement(item) {
    return exports.reflection.isInstance(item, exports.Statement);
}
exports.isStatement = isStatement;
exports.Assignment = 'Assignment';
function isAssignment(item) {
    return exports.reflection.isInstance(item, exports.Assignment);
}
exports.isAssignment = isAssignment;
exports.Bloc = 'Bloc';
function isBloc(item) {
    return exports.reflection.isInstance(item, exports.Bloc);
}
exports.isBloc = isBloc;
exports.BooleanConst = 'BooleanConst';
function isBooleanConst(item) {
    return exports.reflection.isInstance(item, exports.BooleanConst);
}
exports.isBooleanConst = isBooleanConst;
exports.Conjunction = 'Conjunction';
function isConjunction(item) {
    return exports.reflection.isInstance(item, exports.Conjunction);
}
exports.isConjunction = isConjunction;
exports.Disjunction = 'Disjunction';
function isDisjunction(item) {
    return exports.reflection.isInstance(item, exports.Disjunction);
}
exports.isDisjunction = isDisjunction;
exports.FunctionCall = 'FunctionCall';
function isFunctionCall(item) {
    return exports.reflection.isInstance(item, exports.FunctionCall);
}
exports.isFunctionCall = isFunctionCall;
exports.FunctionDef = 'FunctionDef';
function isFunctionDef(item) {
    return exports.reflection.isInstance(item, exports.FunctionDef);
}
exports.isFunctionDef = isFunctionDef;
exports.If = 'If';
function isIf(item) {
    return exports.reflection.isInstance(item, exports.If);
}
exports.isIf = isIf;
exports.Model = 'Model';
function isModel(item) {
    return exports.reflection.isInstance(item, exports.Model);
}
exports.isModel = isModel;
exports.ParallelBloc = 'ParallelBloc';
function isParallelBloc(item) {
    return exports.reflection.isInstance(item, exports.ParallelBloc);
}
exports.isParallelBloc = isParallelBloc;
exports.PeriodicBloc = 'PeriodicBloc';
function isPeriodicBloc(item) {
    return exports.reflection.isInstance(item, exports.PeriodicBloc);
}
exports.isPeriodicBloc = isPeriodicBloc;
exports.Plus = 'Plus';
function isPlus(item) {
    return exports.reflection.isInstance(item, exports.Plus);
}
exports.isPlus = isPlus;
exports.Variable = 'Variable';
function isVariable(item) {
    return exports.reflection.isInstance(item, exports.Variable);
}
exports.isVariable = isVariable;
exports.VarRef = 'VarRef';
function isVarRef(item) {
    return exports.reflection.isInstance(item, exports.VarRef);
}
exports.isVarRef = isVarRef;
exports.While = 'While';
function isWhile(item) {
    return exports.reflection.isInstance(item, exports.While);
}
exports.isWhile = isWhile;
var SimpleLAstReflection = /** @class */ (function (_super) {
    __extends(SimpleLAstReflection, _super);
    function SimpleLAstReflection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleLAstReflection.prototype.getAllTypes = function () {
        return ['Assignment', 'Bloc', 'BooleanConst', 'BooleanExpression', 'Conjunction', 'Disjunction', 'Expr', 'FunctionCall', 'FunctionDef', 'If', 'Model', 'ParallelBloc', 'PeriodicBloc', 'Plus', 'Statement', 'VarRef', 'Variable', 'While'];
    };
    SimpleLAstReflection.prototype.computeIsSubtype = function (subtype, supertype) {
        switch (subtype) {
            case exports.Assignment:
            case exports.Bloc:
            case exports.FunctionCall:
            case exports.If:
            case exports.ParallelBloc:
            case exports.PeriodicBloc:
            case exports.Variable:
            case exports.While:
            case exports.Expr: {
                return this.isSubtype(exports.Statement, supertype);
            }
            case exports.BooleanConst:
            case exports.Conjunction:
            case exports.Disjunction: {
                return this.isSubtype(exports.BooleanExpression, supertype);
            }
            case exports.Plus:
            case exports.VarRef:
            case exports.BooleanExpression: {
                return this.isSubtype(exports.Expr, supertype);
            }
            default: {
                return false;
            }
        }
    };
    SimpleLAstReflection.prototype.getReferenceType = function (refInfo) {
        var referenceId = "".concat(refInfo.container.$type, ":").concat(refInfo.property);
        switch (referenceId) {
            case 'Assignment:variable':
            case 'VarRef:theVar': {
                return exports.Variable;
            }
            case 'FunctionCall:theFunction': {
                return exports.FunctionDef;
            }
            default: {
                throw new Error("".concat(referenceId, " is not a valid reference id."));
            }
        }
    };
    SimpleLAstReflection.prototype.getTypeMetaData = function (type) {
        switch (type) {
            case 'Bloc': {
                return {
                    name: 'Bloc',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'FunctionCall': {
                return {
                    name: 'FunctionCall',
                    mandatory: [
                        { name: 'args', type: 'array' }
                    ]
                };
            }
            case 'FunctionDef': {
                return {
                    name: 'FunctionDef',
                    mandatory: [
                        { name: 'params', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'functionDefs', type: 'array' },
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'ParallelBloc': {
                return {
                    name: 'ParallelBloc',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    };
    return SimpleLAstReflection;
}(langium_1.AbstractAstReflection));
exports.SimpleLAstReflection = SimpleLAstReflection;
exports.reflection = new SimpleLAstReflection();
